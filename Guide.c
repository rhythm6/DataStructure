#define _CRT_SECURE_NO_WARNINGS 1
//数据结构 
/*
二分查找的时间复杂度:
在N个长度的有顺序的数组中 每次与数组中间的元素比较 然后缩小一半(缩小一次查一次 ) 每次除2
x是查的次数
找到你想要的值 最坏情况是 2^x = N     O=(log2N)

递归算法如何计算:递归次数*每次递归的次数
阶乘递归的时间复杂度
long long Factorial的时间复杂度   
long long Factorial(size_t N)
{
return N< 2 ? N: Factorial(N-1)*N;

}斐波那契数列 第一行 2^0 个元素 第二行2^1个元素
//第三行 2^2 个元素 N行一共有2^N  -1个元素
//所以时间复杂度O= (2^N)
顺序表
1.可动态增长的数组
2.数据在数组中存储时必须是连续的

缺点:
1.中间或者头部的插入删除很慢,需要挪动数据。时间复杂度是O(n)
2.空间不够使,增容会有一定消耗和空间浪费。

优点:
1.最大的一个优点 可以随机访问 
2.缓存命中率比较高。(跟链式结构做对比)
系统优先访问缓存
缓存访问一个数据时不会只加载一个数据到缓存，而是这个数据开始的一段数据到缓存
这叫预加载
由于顺序表的数据都是连续存放)(每次预加载都是加载一大段) 系统访问预加载的数据很容易找到 这就叫命中率高
.尾插 尾删 很快(不用挪动数据) 也基本只用这个功能
//下面这三行 总共组成2x2x2种链表 单向带头循环 
单向 双向
带头 不带头
循环 非循环

链表
缺点:以结点为单位存储，不支持随机访问

优点:任意位置插入删除时间复杂度为O(1)
没有增容消耗,按需申请结点空间,不用了直接释放

栈:一种特殊的线性表,其只允许在固定的一段进行插入和删除元素操作。
进行数据插入和删除操作的一端叫做栈顶，另一端叫做栈底。栈中的数据元素遵守
后进先出LIFO(Last in Fist Out)(先进后出)的原则
压栈:栈的插入操作叫做进栈/压栈/入栈 入数据在栈顶
出栈:栈的删除操作叫做出栈，出数据也在栈顶
栈的实现非常灵活 顺序表和链表都可以实现栈

用数组(顺序表)做 用尾做栈顶，非常合适(简单,高效) 综合效率比链表高一点
唯一缺点:还是增容问题
用链表做
1若用尾做栈顶，用双向链表更好 (找尾方便)
2若果要用单链表实现,就用头去做栈顶 入栈出栈效率都是O(1)

但是由于一些取舍:
(顺序表省一点内存(能省一个指针省一个指针，还有内存的局部性原理，这个省的多)) 最终还是选择顺序表实现

队列只允许在一端进行插入数据操作,在另一端进行删除数据
队列具有先进先出的性质FIFO(First In First Out )
入队列:进行插入操作的一端称位队尾
出队列:进行删除操作的一端称位对头
*/
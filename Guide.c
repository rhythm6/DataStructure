#define _CRT_SECURE_NO_WARNINGS 1
//数据结构 
/*
二分查找的时间复杂度:
在N个长度的有顺序的数组中 每次与数组中间的元素比较 然后缩小一半(缩小一次查一次 ) 每次除2
x是查的次数
找到你想要的值 最坏情况是 2^x = N     O=(log2N)

递归算法如何计算:递归次数*每次递归的次数
阶乘递归的时间复杂度
long long Factorial的时间复杂度   
long long Factorial(size_t N)
{
return N< 2 ? N: Factorial(N-1)*N;

}斐波那契数列 第一行 2^0 个元素 第二行2^1个元素
//第三行 2^2 个元素 N行一共有2^N  -1个元素
//所以时间复杂度O= (2^N)
顺序表
1.可动态增长的数组
2.数据在数组中存储时必须是连续的

缺点:
1.中间或者头部的插入删除很慢,需要挪动数据。时间复杂度是O(n)
2.空间不够使,增容会有一定消耗和空间浪费。

优点:
1.最大的一个优点 可以随机访问 
2.缓存命中率比较高。(跟链式结构做对比)
系统优先访问缓存
缓存访问一个数据时不会只加载一个数据到缓存，而是这个数据开始的一段数据到缓存
这叫预加载
由于顺序表的数据都是连续存放)(每次预加载都是加载一大段) 系统访问预加载的数据很容易找到 这就叫命中率高
.尾插 尾删 很快(不用挪动数据) 也基本只用这个功能
//下面这三行 总共组成2x2x2种链表 单向带头循环 
单向 双向
带头 不带头
循环 非循环
*/